module Basic where

let id : (A : Type) → A → A = λ A x → x

let const : (A B : Type) → A → B → A = λ A B x _ → x

let flip : (A B C : Type) → (A → B → C) → B → A → C = λ A B C f x y → f y x

let comp : (A B C : Type) → (B → C) → (A → B) → A → C = λ A B C f g x → f (g x)

let app : (A : Type) (B : (x : A) → Type) (f : (x : A) → B x) (x : A) → B x = λ A B f x → f x

let proj1 : (A : Type) (B : (x : A) → Type) → Σ x : A. B x → A = λ A B p → p.1

let proj2 : (A : Type) (B : (x : A) → Type) (p : Σ x : A. B x) → B (Basic.proj1 p) = λ A B p → p.2

let assoc : (A : Type) (B : (x : A) → Type) (C : Σ x : A. B x → Type) → Σ p : (Σ x : A. B x). C p → Σ x : A. Σ y : B x. C (x , y) = λ p → p.1.1 , p.1.2 , p.2

let sym : (A : Type) (x y : A) → Eq A x y → Eq A y x =
  λ A x → eqElim A x (λ y _ → Eq A y x) (refl A x)

let trans : (A : Type) (x y z : A) → Eq A x y → Eq A y z → Eq A x z =
  λ A x y z p q → eqElim A y (λ w _ → Eq A x w) p z q

let cong : (A B : Type) (f : A → B) (x y : A) → Eq A x y → Eq B (f x) (f y) =
  λ A B f x → eqElim A x (λ y _ → Eq B (f x) (f y)) (refl B (f x))

let cong2 : (A B C : Type) (f : A → B → C) (x y : A) → Eq A x y → (u v : B) → Eq B u v → Eq C (f x u) (f y v) =
  λ A B C f x →
    eqElim A x (λ y _ → (u v : B) → Eq B u v → Eq C (f x u) (f y v))
      (λ u → eqElim B u (λ v _ → Eq C (f x u) (f x v)) (refl C (f x u)))

let cong-app : (A B : Type) (f g : A → B) → Eq (A → B) f g → (x : A) → Eq B (f x) (g x) =
 λ A B f → eqElim (A → B) f (λ h _ → (x : A) → Eq B (f x) (h x)) (λ x → refl B (f x))

let subst : (A : Type) (B : (x : A) → Type) (x y : A) → Eq A x y → B x → B y =
  λ A B x y eq Bx → eqElim A x (λ z _ → B z) Bx y eq

let transport : (A B : Type) → Eq Type A B → A → B =
  λ A B eq x → subst Type (id Type) A B eq x

let add : Nat → Nat → Nat =
  λ m n → natElim (Basic.const Type Nat Nat) (λ _ → suc) n m

let add-id-l : (n : Nat) → Eq Nat (add 0 n) n = refl Nat

let add-id-r : (n : Nat) → Eq Nat (add n 0) n =
  natElim
    (λ n → Eq Nat (add n 0) n)
    (refl Nat 0)
    (λ n → cong Nat Nat suc (add n 0) n)

let add-suc : (m n : Nat) → Eq Nat (add m (suc n)) (suc (add m n)) =
  natElim (λ m → (n : Nat) → Eq Nat (add m (suc n)) (suc (add m n)))
    (λ n → refl Nat (suc n))
    (λ m ih n → cong Nat Nat suc (add m (suc n)) (suc (add m n)) (ih n))

let add-comm : (m n : Nat) → Eq Nat (add m n) (add n m) =
  natElim (λ m → (n : Nat) → Eq Nat (add m n) (add n m))
    (λ n → sym Nat (add n 0) n (add-id-r n))
    (λ m ih n →
      trans Nat (suc (add m n)) (suc (add n m)) (add n (suc m))
        (cong Nat Nat suc (add m n) (add n m) (ih n))
        (sym Nat (add n (suc m)) (suc (add n m)) (add-suc n m)))

let add-assoc : (l m n : Nat) → Eq Nat (add (add l m) n) (add l (add m n)) =
  natElim (λ l → (m n : Nat) → Eq Nat (add (add l m) n) (add l (add m n)))
    (λ m n → refl Nat (add m n))
    (λ l ih m n →
      cong Nat Nat suc (add (add l m) n) (add l (add m n)) (ih m n))

let mul : Nat → Nat → Nat =
  λ m n → natElim (λ _ → Nat) (λ _ → Basic.add n) 0 m

let mul-zero-l : (n : Nat) → Eq Nat (mul 0 n) 0 =
  λ n → refl Nat 0

let mul-zero-r : (n : Nat) → Eq Nat (mul n 0) 0 =
  natElim (λ n → Eq Nat (mul n 0) 0)
    (refl Nat 0)
    (λ n ih → ih)

let mul-id-l : (n : Nat) → Eq Nat (mul 1 n) n =
  natElim
    (λ n → Eq Nat (mul 1 n) n)
    (refl Nat 0)
    (λ n → cong Nat Nat suc (add n 0) n)

let mul-id-r : (n : Nat) → Eq Nat (mul n 1) n =
  natElim
    (λ n → Eq Nat (mul n 1) n)
    (refl Nat 0)
    (λ n → cong Nat Nat suc (add n 0) n)
