module Basic where

let id : (A : Type) → A → A = λ A x → x

let const : (A B : Type) → A → B → A = λ A B x _ → x

let flip : (A B C : Type) → (A → B → C) → B → A → C = λ A B C f x y → f y x

let comp : (A B C : Type) → (B → C) → (A → B) → A → C = λ A B C f g x → f (g x)

let app : (A : Type) (B : (x : A) → Type) → ((x : A) → B x) → (x : A) → B x = λ A B f x → f x

let swap : (A B : Type) → A * B → B * A = λ A B p → p.2 , p.1

let assoc : (A : Type) (B : (x : A) → Type) (C : Σ x : A. B x → Type) → Σ p : (Σ x : A. B x). C p → Σ x : A. Σ y : B x. C (x , y) = λ p → p.1.1 , p.1.2 , p.2

let sym : (A : Type) (x y : A) → Eq A x y → Eq A y x =
  λ A x → eqElim A x (λ y _ → Eq A y x) (refl A x)

let trans : (A : Type) (x y z : A) → Eq A x y → Eq A y z → Eq A x z =
  λ A x y z p q → eqElim A y (λ w _ → Eq A x w) p z q

let cong : (A B : Type) (f : A → B) (x y : A) → Eq A x y → Eq B (f x) (f y) =
  λ A B f x → eqElim A x (λ y _ → Eq B (f x) (f y)) (refl B (f x))

let cong2 : (A B C : Type) (f : A → B → C) (x y : A) → Eq A x y → (u v : B) → Eq B u v → Eq C (f x u) (f y v) =
  λ A B C f x →
    eqElim A x (λ y _ → (u v : B) → Eq B u v → Eq C (f x u) (f y v))
      (λ u → eqElim B u (λ v _ → Eq C (f x u) (f x v)) (refl C (f x u)))

let cong-app : (A B : Type) (f g : A → B) → Eq (A → B) f g → (x : A) → Eq B (f x) (g x) =
 λ A B f → eqElim (A → B) f (λ h _ → (x : A) → Eq B (f x) (h x)) (λ x → refl B (f x))

let subst : (A : Type) (B : (x : A) → Type) (x y : A) → Eq A x y → B x → B y =
  λ A B x y eq Bx → eqElim A x (λ z _ → B z) Bx y eq

let transport : (A B : Type) → Eq Type A B → A → B =
  λ A B eq x → subst Type (id Type) A B eq x

let LeftIdentity : (A : Type) (op : A → A → A) (e : A) → Type =
  λ A op e → (x : A) → Eq A (op e x) x

let RightIdentity : (A : Type) (op : A → A → A) (e : A) → Type =
  λ A op e → (x : A) → Eq A (op x e) x

let Commutativity : (A : Type) (op : A → A → A) → Type =
  λ A op → (x y : A) → Eq A (op x y) (op y x)

let Associativity : (A : Type) (op : A → A → A) → Type =
  λ A op → (x y z : A) → Eq A (op x (op y z)) (op (op x y) z)

let add : Nat → Nat → Nat =
  λ m n → natElim (Basic.const Type Nat Nat) (λ _ → suc) n m

let add-id-l : LeftIdentity Nat add 0 = refl Nat

let add-id-r : RightIdentity Nat add 0 =
  natElim
    (λ n → Eq Nat (add n 0) n)
    (λ n → cong Nat Nat suc (add n 0) n)
    (refl Nat 0)

let add-suc : (m n : Nat) → Eq Nat (add m (suc n)) (suc (add m n)) =
  natElim (λ m → (n : Nat) → Eq Nat (add m (suc n)) (suc (add m n)))
    (λ m ih n → cong Nat Nat suc (add m (suc n)) (suc (add m n)) (ih n))
    (λ n → refl Nat (suc n))

let add-comm : Commutativity Nat add =
  natElim (λ m → (n : Nat) → Eq Nat (add m n) (add n m))
    (λ m ih n →
      trans Nat (suc (add m n)) (suc (add n m)) (add n (suc m))
        (cong Nat Nat suc (add m n) (add n m) (ih n))
        (sym Nat (add n (suc m)) (suc (add n m)) (add-suc n m)))
    (λ n → sym Nat (add n 0) n (add-id-r n))

let add-assoc : Associativity Nat add =
  natElim (λ l → (m n : Nat) → Eq Nat (add (add l m) n) (add l (add m n)))
    (λ l ih m n →
      cong Nat Nat suc (add (add l m) n) (add l (add m n)) (ih m n))
    (λ m n → refl Nat (add m n))

let mul : Nat → Nat → Nat =
  λ m n → natElim (λ _ → Nat) 0 (λ _ → Basic.add n) m

let mul-zero-l : (n : Nat) → Eq Nat (mul 0 n) 0 =
  λ n → refl Nat 0

let mul-zero-r : (n : Nat) → Eq Nat (mul n 0) 0 =
  natElim (λ n → Eq Nat (mul n 0) 0)
    (λ n ih → ih)
    (refl Nat 0)

let mul-id-l : LeftIdentity Nat mul 0 =
  natElim
    (λ n → Eq Nat (mul 1 n) n)
    (λ n → cong Nat Nat suc (add n 0) n)
    (refl Nat 0)

let mul-id-r : RightIdentity Nat mul 0 =
  natElim
    (λ n → Eq Nat (mul n 1) n)
    (λ n → cong Nat Nat suc (add n 0) n)
    (refl Nat 0)

let List : Type → Type = λ A → (X : Type) → X → (A → X → X) → X

let nil : (A : Type) → List A = λ A → λ X n c → n

let cons : (A : Type) → A → List A → List A = λ A x xs X n c → c x (xs X n c)

let foldr : (A B : Type) → (A → B → B) → B → List A → B = λ A B f z xs → xs B z f
